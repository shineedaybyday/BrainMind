# 时间复杂度和空间复杂度

## 时间复杂度

**1. O(1) 之一击必杀**

首先我们必须明确一个概念，O(1) 只是常量级时间复杂度的一种表示方法，并不是指只执行了一行代码。比如这段代码，即便有 3 行，它的时间复杂度也是 O(1），而不是 O(3)。

```
int a = 1;
int b = 2;
int c = 3;
```

我们的 `HashMap get()、put()` ，其实就是 O(1) 时间复杂度。

只要代码的执行时间不随 n 的增大而增长，这样代码的时间复杂度我们都记作 O(1)。或者说，**一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1)**。

**2. O(logn)、O(nlogn)**

对数阶时间复杂度非常常见，同时也是最难分析的一种时间复杂度。

```c++
i=1;
 while (i <= n)  {
   i = i * 2;
 }
```

根据我们前面讲的复杂度分析方法，第三行代码是循环执行次数最多的。所以，我们只要能计算出这行代码被执行了多少次，就能知道整段代码的时间复杂度。

**从代码中可以看出，变量 i 的值从 1 开始取，每循环一次就乘以 2。当大于 n 时，循环结束**。还记得我们高中学过的等比数列吗？实际上，变量 i 的取值就是一个等比数列。如果我把它一个一个列出来，就应该是这个样子的：



所以，我们只要知道 x 值是多少，就知道这行代码执行的次数了。**通过****2**x**=n 求解 x 这个问题我们高中就学过了，可以得出 x=log2 n，所以，这段代码的时间复杂度就是 O(\**log2 n\**)。**

我把代码稍微改下，大家一起看看下面这段代码的时间复杂度是多少？

```c++
 i=1;
 while (i <= n)  {
   i = i * 3;
 }
```

很简单就能看出来，这段代码的时间复杂度为 O(log3 n)。

实际上，不管是以 2 为底、以 3 为底，还是以 10 为底，我们可以把所有对数阶的时间复杂度都记为 O(logn)。为什么呢？

我们知道，对数之间是可以互相转换的，log3 n 就等于 log3 2 * log2n，所以 O(log3 n) = O(C *log2n)，其中 C= log3 2是一个常量。基于我们前面的一个理论：**在采用大 O 标记复杂度的时候，可以忽略系数，即 O(Cf(n)) = O(f(n))**。所以，O(log2 n) 就等于 O(log3 n)。因此，在对数阶时间复杂度的表示方法里，我们忽略对数的“底”，统一表示为 O(logn)。

如果你理解了前面讲的 O(logn)，那 O(nlogn) 就很容易理解了。还记得我们刚讲的乘法法则吗？如果一段代码的时间复杂度是 O(logn)，我们循环执行 n 遍，时间复杂度就是 O(nlogn) 了。而且，O(nlogn) 也是一种非常常见的算法时间复杂度。比如，归并排序、快速排序的时间复杂度都是 O(nlogn)。

如下所示就是O(nlogn)，内部 while循环是 O(logn)，被外层 for 循环包起来。

```c++
for(m = 1; m < n; m++) {
    i = 1;
    while(i < n) {
        i = i * 2;
    }
    }
```

**3. O(m+n)、O(m\*n)**

我们再来讲一种跟前面都不一样的时间复杂度，代码的复杂度**由两个数据的规模**来决定。

```
int cal(int m, int n) {
  int sum_1 = 0;
  int i = 1;
  for (; i < m; ++i) {
    sum_1 = sum_1 + i;
  }
 
  int sum_2 = 0;
  int j = 1;
  for (; j < n; ++j) {
    sum_2 = sum_2 + j;
  }
 
  return sum_1 + sum_2;
}
```

从代码中可以看出，m 和 n 是表示两个数据规模。我们无法事先评估 m 和 n 谁的量级大，所以我们在表示复杂度的时候，就不能简单地利用加法法则，省略掉其中一个。因此，上面代码的时间复杂度就是 O(m+n)。

针对这种情况，原来的加法法则就不正确了，我们需要将加法规则改为：T1(m) + T2(n) = O(f(m) + g(n))。但是乘法法则继续有效：T1(m)*T2(n) = O(f(m) * f(n))。

**4.线性阶O(n)** 

看下面这段代码会执行多少次呢？

```
for(i=1; i<=n; i++) {
   j = i;
   j++;
}
```

第1行会执行 n 次，第2行和第3行会分别执行n次，总的执行时间也就是 3n + 1 次，那它的时间复杂度表示是 O(3n + 1) 吗？No !

还是那句话：**“大O符号表示法并不是用来真实代表算法的执行时间的，它是用来表示代码执行时间的增长变化趋势的”**。

所以它的时间复杂度其实是O(n);

**5.平方阶O(n²)**

```
for(x=1; i <= n; x++){
   for(i = 1; i <= n; i++) {
       j = i;
       j++;
    }
}
```

把 O(n) 的代码再嵌套循环一遍，它的时间复杂度就是 O(n²) 了。

**6.立方阶O(n³)、K次方阶O(nk)**

参考上面的O(n²) 去理解就好了，O(n³)相当于三层n循环，其它的类似。

## 空间复杂度

时间复杂度的全称是**渐进时间复杂度**，**表示算法的执行时间与数据规模之间的增长关系**。类比一下，空间复杂度全称就是**渐进空间复杂度**，**表示算法的存储空间与数据规模之间的增长关系**。

```
void print(int n) {
  int i = 0;
  int[] a = new int[n];
  for (i; i <n; ++i) {
    a[i] = i * i;
  }
}
```

跟时间复杂度分析一样，我们可以看到，第 2 行代码中，我们申请了一个空间存储变量 i，但是它是常量阶的，跟数据规模 n 没有关系，所以我们可以忽略。第 3 行申请了一个大小为 n 的 int 类型数组，除此之外，剩下的代码都没有占用更多的空间，所以整段代码的空间复杂度就是 O(n)。

打个不恰当的比喻，就像我们的手机，现在工艺越来越好，手机也越来越薄，占用体积越来越小。也就是用更好的模具设计放置零件，而模具就像是空间复杂度，更小的体积容纳更多的原件。

我们常见的空间复杂度就是 O(1)、O(n)、O(n²)，像 O(logn)、O(nlogn) 这样的对数阶复杂度平时都用不到。而且，空间复杂度分析比时间复杂度分析要简单很多。所以，对于空间复杂度，掌握刚我说的这些内容已经足够了。

### 空间复杂度 O(1)

如果算法执行所需要的临时空间不随着某个变量n的大小而变化，即此算法空间复杂度为一个常量，可表示为 O(1)。

```
int i = 1;
int j = 2;
++i;
j++;
int m = i + j;
```

### 空间复杂度 O(n)

```
int[] m = new int[n]
for(i=1; i <= n; ++i) {
   j = i;
   j++;
}
```

这段代码中，第一行new了一个数组出来，这个数据占用的大小为n，后面虽然有循环，但没有再分配新的空间，因此，这段代码的空间复杂度主要看第一行即可，即 S(n) = O(n)。